---
title: "tuxedoRNAseq"
output: pdf_document
---

Loading ballgown and associated packages
```{r}
source("https://bioconductor.org/biocLite.R")
biocLite()
library(ballgown)
library(genefilter)
library(dplyr)
library(devtools)
```



Read in pheno data
```{r}
ballgownPhenodata <- read.csv("~/hisatAnalysis/ballgownPhenodata.csv")
```

Read in ballgown data (counts)
```{r}
ballgownData <- ballgown(dataDir = "/home/mcity599/hisatAnalysis/ballgown/", samplePattern = "sample", pData = ballgownPhenodata)
# Running as per the publication instructions generates this error:
## Rows of pData did not seem to be in the same order as the columns of the expression data. Attempting to rearrange pData...Error in ballgown(dataDir = "/home/mcity599/hisatAnalysis/ballgown/",  : 
##  first column of pData does not match the names of the folders containing the ballgown data.

ballgownData <- ballgown(dataDir = "/home/mcity599/hisatAnalysis/ballgown/", samplePattern = "")
# Can successfully load the ballgown information by itself

# The problem can be seen here:
list.files("/home/mcity599/hisatAnalysis/ballgown/")

## I looked into re-sorting one of these files, but that seems dangerous should I ever need to re-analyse or forget to re-sort at a later date. Instead I've renamed the sample files as sampleA, sampleB
# Repeat the process above, and it now functions properly
```



Filter to remove low abundance or low variance transcripts
# In this instance, remove transcripts with an across-sample variance of less than one
```{r}
filteredData <- subset(ballgownData, "rowVars(texpr(ballgownData)) > 1", genomesubset=T)
texpr(filteredData)[1:10,1:5] # Can be used to view and therefore access the actual counts
dim(texpr(filteredData))
dim(texpr(ballgownData))
rownames(filteredData)
# Observe that there are only ~38,000 rows post filtering, with 145,000 pre-filtering. 
```



## From the Tuxedo nature publication:
Note that Ballgown’s statistical test is a standard linear model-based comparison. For small sample sizes (n< 4 per group), it is often better to perform regularization. This can be done using the limma package in Bioconductor. 
Other regularized methods such as DESeq and edgeR can be applied to gene or exon counts, but they are not appropriate for direct application to FPKM abundance estimates. The statistical test uses a cumulative upper 
quartile normalization.

```{r}
full_table <- texpr(ballgownData , 'all')
full_table[1:10,]
```

# This shows me the counts (which are in FPKM) - looks like I might need to find raw counts rather than FPKM
#    # Can use full_table <- texpr(ballgownData , 'all') for viewing information on gene_name etc.,




Browsing around to find information on the topic of limma-voom or regularization I came across this:
https://www.biostars.org/p/307580/
- One answer suggests using StringTie-generated gtf file with original fastQ file to determine raw read count abundances with Salmon. Then can input those raw counts into DESeq2
- Another answer suggests using featureCounts with the stringtie gtf, which can be interpreted by EdgeR or DESeq2.

This seems like a plausible work-around, especially since I already have code for Salmon, DESeq and edgeR. 




20180718
==============================================================================================================================================================================================================================

Yesterday I spent some time looking into different ways to integrate the Hisat/stringtie output into a DESeq2/EdgeR analysis. Rather than using Salmon to re-do the alignments and finding something to do the counts, I've used a simple python script* to extract count data at both the gene and transcript level for all samples. The script produces two output files (genes, transcripts) with counts for all samples in columns. Rows are individual genes/transcripts, named by MSTRG.xxxx, which match up to the stringtie names from the .gtf files. 

*
wget https://ccb.jhu.edu/software/stringtie/dl/prepDE.py
python prepDE.py -i /home/mcity599/hisatAnalysis/ballgown/
With help from this site: https://ccb.jhu.edu/software/stringtie/index.shtml?t=manual#deseq


Following the stringtie manual linked directly above, I will walkthrough the analysis:

```{r}
source("https://bioconductor.org/biocLite.R")
biocLite()
biocLite("DESeq2")
library(DESeq2)

# Read in count data:
countData <- as.matrix(read.csv("~/hisatAnalysis/stringtie_prepDE_output/stringtiePrepDE_geneCountMatrix.csv", row.names="gene_id"))
# Load sample information:
sampleInformation <- read.csv("~/hisatAnalysis/ballgownPhenodata.csv")
# Check that sample ID match between countData and sampleInformation
all(sampleInformation$ids %in% colnames(countData))

# Create a DESeqDataSet from count matrix and labels
dds <- DESeqDataSetFromMatrix(countData = countData, colData = sampleInformation, design = ~ TissueType)
# Run the default analysis for DESeq2 and generate a results table:
dds <- DESeq(dds)
# **
res <- results(dds)
# Sort by adjusted p-value and display:
resOrdered <- res[order(res$padj),]
resOrdered[1:100,]
```
** Note that the first time I ran this analysis I got an error about the design matrix having the same number of samples and coefficients to fit. This was because phenoData/sampleInformation originally had tissueType as WTa, WTb etc., which meant there were no reps. I have updated the ballgownPhenoData.csv file to reflect the presence of replicates.


## Table notes:
This produces a table of adjusted p.values. 
Gene names are present as MSTRG.xxxx and need to be converted to something useful.
The log2 fold change is for TissueType WT blast (underscore is not shown?) vs ConCap - I will need to further specify what I want to test using combinations with design. 
I have an adjusted p value of 1.2e-277 (!!!!)
In the previous analysis I did something where I adjusted for high and low expression (and how this relates to st.dev??). I need to re-read the notes from that analysis and find the code that was used, does this adjustment need to be done now. 


Additional arguments and things (e.g., shrinkage)
#################################################
## Notes from 20180213:
# Differential expression analysis
The standard differential expression analysis steps are wrapped into a single function, DESeq. The estimation steps performed by this function are described below, in the manual page for ?DESeq and in the Methods section of the DESeq2 publication (Love, Huber, and Anders 2014).
Results tables are generated using the function results, which extracts a results table with log2 fold changes, p values and adjusted p values. With no additional arguments to results, the log2 fold change and Wald test p value will be for the last variable in the design formula, and if this is a factor, the comparison will be the last level of this variable over the first level. However, the order of the variables of the design do not matter so long as the user specifies the comparison using the name or contrast arguments of results (described later and in ?results).
Details about the comparison are printed to the console, above the results table. The text, condition treated vs untreated, tells you that the estimates are of the logarithmic fold change log2(treated/untreated).
# Shrinkage
DESeq2 walkthrough mentions shrinkage estimate, which I've found an explanation for:
In previous versions of DESeq2, the DESeq function by default would produce moderated, or shrunken, log2 fold changes through the use of the betaPrior argument. In version 1.16 and higher, we have split the moderation of log2 fold changes into a separate function, lfcShrink, for reasons described in the changes section below.
Here we provide the dds object and the number of the coefficient we want to moderate. It is also possible to specify a contrast, instead of coef, which works the same as the contrast argument of the results function. If a results object is provided, the log2FoldChange column will be swapped out, otherwise lfcShrink returns a vector of shrunken log2 fold changes.
 Full methods are described in the DESeq2 paper (see DESeq2 citation), but in short, it looks at the largest fold changes that are not due to low counts and uses these to inform a prior distribution. So the large fold changes from genes with lots of statistical information are not shrunk, while the imprecise fold changes are shrunk. This allows you to compare all estimated LFC across experiments, for example, which is not really feasible without the use of a prior.
  - https://support.bioconductor.org/p/77461/

The code I used for shrinkage:
```{r}
# Make smaller version of dds which only looks at the first experiment
dds <- DESeqDataSetFromMatrix(countData = countData[,1:6], colData = sampleInformation[1:6,], design = ~ TissueType)
# Run the default analysis for DESeq2 and generate a results table:
dds <- DESeq(dds)
res <- results(dds)

# Carry out lfc shrinkage, based on the coef of choice (which I learn from resultsNames)
resultsNames(dds)
resLFC <- lfcShrink(dds, coef=2)

res[1:10,]
resLFC[1:10,]
# Shrinkage has been carried out, which can be observed in the log2FoldChange and lfcSE columns only. 

resLFCordered <- resLFC[order(resLFC$padj),]
resLFCordered[1:10,]

plotMA(res)
plotMA(resLFC)
# These code also came from the bioconductor support page linked directly above, but I am not really sure how to interpret. They do show a distinctive difference post lfc shrinkage
```

  
  

20180719
===================================================================================================================


Gain a better understanding of how to use the contrast argument in the DESeq results function. 
#############################################################################################
```{r}
# https://www.bioconductor.org/packages/devel/bioc/manuals/DESeq2/man/DESeq2.pdf page 41
res <- results(dds)
resConTest1 <- results(dds, contrast = c("TissueType","WT_blast","N1_nr"))
resConTest2 <- results(dds, contrast = c("TissueType","N1_nr","WT_blast"))
res[1:10,]
resConTest1[1:10,]
resConTest2[1:10,]
# These contrast tests demonstrate that log2FoldChange is reversed between 1 and 2. In the first instance, it is log2(WT_blast/N1_nr)

# This also shows how I can test for differences between specific conditions:
dds <- DESeqDataSetFromMatrix(countData = countData, colData = sampleInformation, design = ~ TissueType)
dds <- DESeq(dds)
sampleInformation
resConTest3 <- results(dds, contrast = c("TissueType","Tbud","PNT"))
resConTest3[1:10,]
resConTest4 <- results(dds, contrast = c("TissueType","ConCap","InjCap"))
resConTest4[1:10,]
# These share the same top genes, and log2FC/ stat do not appear to be appreciably different. 

resOrdered <- res[order(res$padj),]
resConTest3 <- resConTest3[order(resConTest3$padj),]
resConTest4 <- resConTest4[order(resConTest4$padj),]
resConTest3[1:10,]
resConTest4[1:10,]
# Once sorted by padj, the table results of TBud/PNT and ConCap/InjCap are quite different. 
```


Add gene names to LFC adjusted results. 
#############################################################################################
```{r}
stringtieMerged <- read.delim("~/hisatAnalysis/stringtieMerged.gtf", header=FALSE, comment.char="#")
stringtieMerged[1:3,]
dim(stringtieMerged)
spryCor <- grep("spry4",as.character(stringtieMerged[,9]))
as.vector(stringtieMerged[spryCor,9])

library(limma)
strsplit2(as.vector(stringtieMerged[spryCor,9]),";")[,c(1,3)]
# Since I'm working with gene counts, I will first try unique(MSTRGxxx) 

gd <- strsplit2(as.vector(stringtieMerged[,9]),";")[,c(1,3)]
gd[1:10,]
length(gd[,1])
length(unique(gd[,1]))
# 78,000 unique MSTRG
mstrgCodes <- strsplit2(unique(gd[,1])," ",fixed=T)[,2]
mstrgCodes[1:10]
gd[1:10,]
gd <- cbind(strsplit2(gd[,1]," ",fixed=T)[,2],gd[,2])
gd[1:100,]
mstrgToGene <- gd[grep("gene_name",as.vector(gd[,2])),]
dim(mstrgToGene)
length(unique(mstrgToGene[,1])) # 52485 mstrg tags
length(unique(mstrgToGene[,2])) # 49109 gene names
## Therefore some genes have multiple mstrg tags. 
# Which will be ok because the DESEq2 results are per mstrg. Multiple mstrg might map back to the same gene, but I won't have the issue of an mstrg tag mapping to the wrong gene (which could happen if this situation was reversed).


mstrgToGene[1:100,]
## Actually, when I look at the object, I can already see instances where one mstrg code encodes for multiple genes. e.g., mstrg31 matches ND1 and tRNA-Ile
setwd("~/Documents/tuxedoRNASeq/objectsTuxedoDESeq")
save(mstrgToGene,file='mstrgToGene.RData')
```







20180720
========================================================================================================================================================================

A single mstrg.xxxx id can match to multiple reference genes. 
Investigating this now, it is a known and recognised problem: https://github.com/gpertea/stringtie/issues/159
In this post, Pertea (first author of Tuxedo suite walkthrough "Transcript-level expression analysis of RNA-seq using Hisat, Stringtie and ballgown") states:

  "Firstly, please note that the MSTRG.# format .... they are gene (locus) IDs (the transcript IDs will have a different format, with another number added: MSTRG.#.#).

  The other issue you raised is StringTie gene/loci (MSTRG.#) matching multiple reference gene names ...

  This is actually the other reason why StringTie uses its own locus/gene IDs instead of reference gene IDs and names: because there are complex gene clusters like these where the alignments extend across multiple reference loci/genes, so the resulting StringTie locus(gene) encompasses multiple reference genes.. This could be caused by spurious alignments which are somewhat expected in situations like HLA gene clusters, or even intra-intron miRNA genes (like MIR6891) which are easily found to overlap incompletely spliced (or the retained introns of the) transcripts encompassing them (HLA transcripts in this example), and thus they'll be assigned the same StringTie gene/locus ID (MSTRG.18605 in this example).

  And in such "merged" reference loci cases there could be assembled transcripts overlapping reference transcripts belonging to different reference genes..(thus "bridging" those genes). What should StringTie show as the gene name in such cases? Both gene names? So you see, things can get hairy and that's why sticking to its own internally generated locus IDs like MSTRG.18605 is the unambiguous way for StringTie to report the results.
  "
And later states:
  "I agree that the annotation of StringTie's merged output is somewhat lacking at this point.. I am considering improving that in a future version by adding one ore more GTF tags that would actually show which reference gene_id (or gene_name, if the user prefers that) any particular StringTie output transcript might belong to (just by overlap, not by fully matching a reference transcript).
  Currently the user should use third party programs in order to actually annotate those cryptic MSTRG.ID loci and MSTRG.ID.ID transcripts in some cases. GffCompare can address some of it (with its "annotation mode") but I guess it still does not do it quite conveniently enough for easy inclusion in analysis pipelines.
  I'll leave this topic open (and of course take suggestions) until I get around implement (or find) a solution to properly address these needs of gene annotation of StringTie's output..
"
(Edited for clarity)


Moving forward, I will generate lists of DE MSTRG tags and then resolve tags to gene ID as best I can. 

I can now used the lfcShrink code from above to generate DE gene lists for each of the three experiments:

```{r}
rm(list=ls())

# Read in count data:
countData <- as.matrix(read.csv("~/hisatAnalysis/stringtie_prepDE_output/stringtiePrepDE_geneCountMatrix.csv", row.names="gene_id"))
# Load sample information:
sampleInformation <- read.csv("~/hisatAnalysis/ballgownPhenodata.csv")
# Check that sample ID match between countData and sampleInformation
all(sampleInformation$ids %in% colnames(countData))

# Deseq2 object:
dds <- DESeqDataSetFromMatrix(countData = countData, colData = sampleInformation, design = ~ TissueType)
dds <- DESeq(dds)
resultsNames(dds)
# Generate results tables
WTN1res <- results(dds, contrast=c("TissueType", "Wtblast", "N1nr"))
TbudPNTres <- results(dds, contrast=c("TissueType", "Tbud", "PNT"))
ConCapInjCapres <- results(dds, contrast=c("TissueType", "ConCap", "InjCap"))
# Apply lfcShrink
WTN1res.lfc <- lfcShrink(dds, contrast=c("TissueType", "Wtblast", "N1nr"), res = WTN1res)
TbudPNTres.lfc <- lfcShrink(dds, contrast=c("TissueType", "Tbud", "PNT"), res = TbudPNTres)
ConCapInjCapres.lfc <- lfcShrink(dds, contrast=c("TissueType", "ConCap", "InjCap"), res = ConCapInjCapres)


## NOTE: on p-values set to NA
#        If within a row, all samples have zero counts, the baseMean column will be zero, and the log2 fold change estimates, p-value and adjusted p-value will all be set to NA.
#        If a row contains a sample with an extreme count outlier then the p-value and adjusted p-value will be set to NA. These outlier counts are detected by Cook’s distance.
#        If a row is filtered by automatic independent filtering, for having a low mean normalized count, then only the adjusted p-value will be set to NA

dim(WTN1res.lfc) # 77899 by 6
length(as.vector(na.omit(WTN1res.lfc$padj))) # there are 30515 genes with adjusted p values

# Remove rows with padj = NA
WTN1res.lfc <- WTN1res.lfc[!is.na(WTN1res.lfc$padj),]
table(WTN1res.lfc$padj < 0.05) # 2050 p values < 0.05, 28465 above

# Order the results table, retain padj < 0.05
WTN1_ord <- WTN1res.lfc[order(WTN1res.lfc$padj),]
WTN1_ord$padj[1100:2051] # shows that when sorted, the first 2050 p values are < 0.05
WTN1_statSig <- WTN1_ord[as.vector(na.omit(WTN1_ord$padj < 0.05)),]
WTN1_statSig
dim(WTN1_statSig)
rm(WTN1_ord)

# Order by log2FC, retain log2FC >1 or < -1
WTN1_ord <- WTN1_statSig[order(WTN1_statSig$log2FoldChange),]
WTN1_sigNeg <- WTN1_ord[as.vector(na.omit(WTN1_ord$log2FoldChange < -1)),]
WTN1_sigPos <- WTN1_ord[as.vector(na.omit(WTN1_ord$log2FoldChange > 1)),]
WTN1_sigNeg
WTN1_sigPos


wtVSn1nr_DownRegGenes <- mstrgToGene[as.vector(na.omit(match(rownames(WTN1_sigNeg),as.vector(mstrgToGene[,1])))),]
dim(wtVSn1nr_DownRegGenes)
dim(WTN1_sigNeg)
## These are not the same dim. 
```











A note from the stringtie manual hints that I can use the code "DGEList" to bring these counts in for EdgeR analysis, the same as how I've used "DESeqDataSetFromMatrix" above for DESeq2. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
