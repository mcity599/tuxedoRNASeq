---
title: "tuxedoRNAseq"
output: pdf_document
---

Loading ballgown and associated packages
```{r}
source("https://bioconductor.org/biocLite.R")
biocLite()
library(ballgown)
library(genefilter)
library(dplyr)
library(devtools)
```



Read in pheno data
```{r}
ballgownPhenodata <- read.csv("~/hisatAnalysis/ballgownPhenodata.csv")
```

Read in ballgown data (counts)
```{r}
ballgownData <- ballgown(dataDir = "/home/mcity599/hisatAnalysis/ballgown/", samplePattern = "sample", pData = ballgownPhenodata)
# Running as per the publication instructions generates this error:
## Rows of pData did not seem to be in the same order as the columns of the expression data. Attempting to rearrange pData...Error in ballgown(dataDir = "/home/mcity599/hisatAnalysis/ballgown/",  : 
##  first column of pData does not match the names of the folders containing the ballgown data.

ballgownData <- ballgown(dataDir = "/home/mcity599/hisatAnalysis/ballgown/", samplePattern = "")
# Can successfully load the ballgown information by itself

# The problem can be seen here:
list.files("/home/mcity599/hisatAnalysis/ballgown/")

## I looked into re-sorting one of these files, but that seems dangerous should I ever need to re-analyse or forget to re-sort at a later date. Instead I've renamed the sample files as sampleA, sampleB
# Repeat the process above, and it now functions properly
```



Filter to remove low abundance or low variance transcripts
# In this instance, remove transcripts with an across-sample variance of less than one
```{r}
filteredData <- subset(ballgownData, "rowVars(texpr(ballgownData)) > 1", genomesubset=T)
texpr(filteredData)[1:10,1:5] # Can be used to view and therefore access the actual counts
dim(texpr(filteredData))
dim(texpr(ballgownData))
rownames(filteredData)
# Observe that there are only ~38,000 rows post filtering, with 145,000 pre-filtering. 
```



## From the Tuxedo nature publication:
Note that Ballgownâ€™s statistical test is a standard linear model-based comparison. For small sample sizes (n< 4 per group), it is often better to perform regularization. This can be done using the limma package in Bioconductor. 
Other regularized methods such as DESeq and edgeR can be applied to gene or exon counts, but they are not appropriate for direct application to FPKM abundance estimates. The statistical test uses a cumulative upper 
quartile normalization.

```{r}
full_table <- texpr(ballgownData , 'all')
full_table[1:10,]
```

# This shows me the counts (which are in FPKM) - looks like I might need to find raw counts rather than FPKM
#    # Can use full_table <- texpr(ballgownData , 'all') for viewing information on gene_name etc.,




Browsing around to find information on the topic of limma-voom or regularization I came across this:
https://www.biostars.org/p/307580/
- One answer suggests using StringTie-generated gtf file with original fastQ file to determine raw read count abundances with Salmon. Then can input those raw counts into DESeq2
- Another answer suggests using featureCounts with the stringtie gtf, which can be interpreted by EdgeR or DESeq2.

This seems like a plausible work-around, especially since I already have code for Salmon, DESeq and edgeR. 




20180718
==============================================================================================================================================================================================================================

Yesterday I spent some time looking into different ways to integrate the Hisat/stringtie output into a DESeq2/EdgeR analysis. Rather than using Salmon to re-do the alignments and finding something to do the counts, I've used a simple python script* to extract count data at both the gene and transcript level for all samples. The script produces two output files (genes, transcripts) with counts for all samples in columns. Rows are individual genes/transcripts, named by MSTRG.xxxx, which match up to the stringtie names from the .gtf files. 

*
wget https://ccb.jhu.edu/software/stringtie/dl/prepDE.py
python prepDE.py -i /home/mcity599/hisatAnalysis/ballgown/
With help from this site: https://ccb.jhu.edu/software/stringtie/index.shtml?t=manual#deseq


Following the stringtie manual linked directly above, I will walkthrough the analysis:

```{r}
source("https://bioconductor.org/biocLite.R")
biocLite()
biocLite("DESeq2")
library(DESeq2)

# Read in count data:
countData <- as.matrix(read.csv("~/hisatAnalysis/stringtie_prepDE_output/stringtiePrepDE_geneCountMatrix.csv", row.names="gene_id"))
# Load sample information:
sampleInformation <- read.csv("~/hisatAnalysis/ballgownPhenodata.csv")
# Check that sample ID match between countData and sampleInformation
all(sampleInformation$ids %in% colnames(countData))

# Create a DESeqDataSet from count matrix and labels
dds <- DESeqDataSetFromMatrix(countData = countData, colData = sampleInformation, design = ~ TissueType)
# Run the default analysis for DESeq2 and generate a results table:
dds <- DESeq(dds)
# **
res <- results(dds)
# Sort by adjusted p-value and display:
resOrdered <- res[order(res$padj),]
resOrdered[1:100,]
```
** Note that the first time I ran this analysis I got an error about the design matrix having the same number of samples and coefficients to fit. This was because phenoData/sampleInformation originally had tissueType as WTa, WTb etc., which meant there were no reps. I have updated the ballgownPhenoData.csv file to reflect the presence of replicates.


## Table notes:
This produces a table of adjusted p.values. 
Gene names are present as MSTRG.xxxx and need to be converted to something useful.
The log2 fold change is for TissueType WT blast (underscore is not shown?) vs ConCap - I will need to further specify what I want to test using combinations with design. 
I have an adjusted p value of 1.2e-277 (!!!!)
In the previous analysis I did something where I adjusted for high and low expression (and how this relates to st.dev??). I need to re-read the notes from that analysis and find the code that was used, does this adjustment need to be done now. 


Additional arguments and things (e.g., shrinkage)
#################################################
## Notes from 20180213:
# Differential expression analysis
The standard differential expression analysis steps are wrapped into a single function, DESeq. The estimation steps performed by this function are described below, in the manual page for ?DESeq and in the Methods section of the DESeq2 publication (Love, Huber, and Anders 2014).
Results tables are generated using the function results, which extracts a results table with log2 fold changes, p values and adjusted p values. With no additional arguments to results, the log2 fold change and Wald test p value will be for the last variable in the design formula, and if this is a factor, the comparison will be the last level of this variable over the first level. However, the order of the variables of the design do not matter so long as the user specifies the comparison using the name or contrast arguments of results (described later and in ?results).
Details about the comparison are printed to the console, above the results table. The text, condition treated vs untreated, tells you that the estimates are of the logarithmic fold change log2(treated/untreated).
# Shrinkage
DESeq2 walkthrough mentions shrinkage estimate, which I've found an explanation for:
In previous versions of DESeq2, the DESeq function by default would produce moderated, or shrunken, log2 fold changes through the use of the betaPrior argument. In version 1.16 and higher, we have split the moderation of log2 fold changes into a separate function, lfcShrink, for reasons described in the changes section below.
Here we provide the dds object and the number of the coefficient we want to moderate. It is also possible to specify a contrast, instead of coef, which works the same as the contrast argument of the results function. If a results object is provided, the log2FoldChange column will be swapped out, otherwise lfcShrink returns a vector of shrunken log2 fold changes.
 Full methods are described in the DESeq2 paper (see DESeq2 citation), but in short, it looks at the largest fold changes that are not due to low counts and uses these to inform a prior distribution. So the large fold changes from genes with lots of statistical information are not shrunk, while the imprecise fold changes are shrunk. This allows you to compare all estimated LFC across experiments, for example, which is not really feasible without the use of a prior.
  - https://support.bioconductor.org/p/77461/

The code I used for shrinkage:
```{r}
# Make smaller version of dds which only looks at the first experiment
dds <- DESeqDataSetFromMatrix(countData = countData[,1:6], colData = sampleInformation[1:6,], design = ~ TissueType)
# Run the default analysis for DESeq2 and generate a results table:
dds <- DESeq(dds)
res <- results(dds)

# Carry out lfc shrinkage, based on the coef of choice (which I learn from resultsNames)
resultsNames(dds)
resLFC <- lfcShrink(dds, coef=2)

res[1:10,]
resLFC[1:10,]
# Shrinkage has been carried out, which can be observed in the log2FoldChange and lfcSE columns only. 

resLFCordered <- resLFC[order(resLFC$padj),]
resLFCordered[1:10,]

plotMA(res)
plotMA(resLFC)
# These code also came from the bioconductor support page linked directly above, but I am not really sure how to interpret. They do show a distinctive difference post lfc shrinkage
```

  
  

20180719
===================================================================================================================


Gain a better understanding of how to use the contrast argument in the DESeq results function. 
#############################################################################################
```{r}
# https://www.bioconductor.org/packages/devel/bioc/manuals/DESeq2/man/DESeq2.pdf page 41
res <- results(dds)
resConTest1 <- results(dds, contrast = c("TissueType","WT_blast","N1_nr"))
resConTest2 <- results(dds, contrast = c("TissueType","N1_nr","WT_blast"))
res[1:10,]
resConTest1[1:10,]
resConTest2[1:10,]
# These contrast tests demonstrate that log2FoldChange is reversed between 1 and 2. In the first instance, it is log2(WT_blast/N1_nr)

# This also shows how I can test for differences between specific conditions:
dds <- DESeqDataSetFromMatrix(countData = countData, colData = sampleInformation, design = ~ TissueType)
dds <- DESeq(dds)
sampleInformation
resConTest3 <- results(dds, contrast = c("TissueType","Tbud","PNT"))
resConTest3[1:10,]
resConTest4 <- results(dds, contrast = c("TissueType","ConCap","InjCap"))
resConTest4[1:10,]
# These share the same top genes, and log2FC/ stat do not appear to be appreciably different. 

resOrdered <- res[order(res$padj),]
resConTest3 <- resConTest3[order(resConTest3$padj),]
resConTest4 <- resConTest4[order(resConTest4$padj),]
resConTest3[1:10,]
resConTest4[1:10,]
# Once sorted by padj, the table results of TBud/PNT and ConCap/InjCap are quite different. 
```


Add gene names to LFC adjusted results. 
#############################################################################################
```{r}

```



















A note from the stringtie manual hints that I can use the code "DGEList" to bring these counts in for EdgeR analysis, the same as how I've used "DESeqDataSetFromMatrix" above for DESeq2. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
