---
title: "tuxedoRNAseq"
output: pdf_document
---

Loading ballgown and associated packages
```{r}
source("https://bioconductor.org/biocLite.R")
biocLite()
library(ballgown)
library(genefilter)
library(dplyr)
library(devtools)
```



Read in pheno data
```{r}
ballgownPhenodata <- read.csv("~/hisatAnalysis/ballgownPhenodata.csv")
```

Read in ballgown data (counts)
```{r}
ballgownData <- ballgown(dataDir = "/home/mcity599/hisatAnalysis/ballgown/", samplePattern = "sample", pData = ballgownPhenodata)
# Running as per the publication instructions generates this error:
## Rows of pData did not seem to be in the same order as the columns of the expression data. Attempting to rearrange pData...Error in ballgown(dataDir = "/home/mcity599/hisatAnalysis/ballgown/",  : 
##  first column of pData does not match the names of the folders containing the ballgown data.

ballgownData <- ballgown(dataDir = "/home/mcity599/hisatAnalysis/ballgown/", samplePattern = "")
# Can successfully load the ballgown information by itself

# The problem can be seen here:
list.files("/home/mcity599/hisatAnalysis/ballgown/")

## I looked into re-sorting one of these files, but that seems dangerous should I ever need to re-analyse or forget to re-sort at a later date. Instead I've renamed the sample files as sampleA, sampleB
# Repeat the process above, and it now functions properly
```



Filter to remove low abundance or low variance transcripts
# In this instance, remove transcripts with an across-sample variance of less than one
```{r}
filteredData <- subset(ballgownData, "rowVars(texpr(ballgownData)) > 1", genomesubset=T)
texpr(filteredData)[1:10,1:5] # Can be used to view and therefore access the actual counts
dim(texpr(filteredData))
dim(texpr(ballgownData))
rownames(filteredData)
# Observe that there are only ~38,000 rows post filtering, with 145,000 pre-filtering. 
```



## From the Tuxedo nature publication:
Note that Ballgownâ€™s statistical test is a standard linear model-based comparison. For small sample sizes (n< 4 per group), it is often better to perform regularization. This can be done using the limma package in Bioconductor. 
Other regularized methods such as DESeq and edgeR can be applied to gene or exon counts, but they are not appropriate for direct application to FPKM abundance estimates. The statistical test uses a cumulative upper 
quartile normalization.

```{r}
full_table <- texpr(ballgownData , 'all')
full_table[1:10,]
```

# This shows me the counts (which are in FPKM) - looks like I might need to find raw counts rather than FPKM
#    # Can use full_table <- texpr(ballgownData , 'all') for viewing information on gene_name etc.,




Browsing around to find information on the topic of limma-voom or regularization I came across this:
https://www.biostars.org/p/307580/
- One answer suggests using StringTie-generated gtf file with original fastQ file to determine raw read count abundances with Salmon. Then can input those raw counts into DESeq2
- Another answer suggests using featureCounts with the stringtie gtf, which can be interpreted by EdgeR or DESeq2.

This seems like a plausible work-around, especially since I already have code for Salmon, DESeq and edgeR. 




20180718
==============================================================================================================================================================================================================================

Yesterday I spent some time looking into different ways to integrate the Hisat/stringtie output into a DESeq2/EdgeR analysis. Rather than using Salmon to re-do the alignments and finding something to do the counts, I've used a simple python script* to extract count data at both the gene and transcript level for all samples. The script produces two output files (genes, transcripts) with counts for all samples in columns. Rows are individual genes/transcripts, named by MSTRG.xxxx, which match up to the stringtie names from the .gtf files. 

*
wget https://ccb.jhu.edu/software/stringtie/dl/prepDE.py
python prepDE.py -i /home/mcity599/hisatAnalysis/ballgown/
With help from this site: https://ccb.jhu.edu/software/stringtie/index.shtml?t=manual#deseq


Following the stringtie manual linked directly above, I will walkthrough the analysis:

```{r}
source("https://bioconductor.org/biocLite.R")
biocLite()
biocLite("DESeq2")
library(DESeq2)

# Read in count data:
countData <- as.matrix(read.csv("~/hisatAnalysis/stringtie_prepDE_output/stringtiePrepDE_geneCountMatrix.csv", row.names="gene_id"))
# Load sample information:
sampleInformation <- read.csv("~/hisatAnalysis/ballgownPhenodata.csv")
# Check that sample ID match between countData and sampleInformation
all(sampleInformation$ids %in% colnames(countData))

# Create a DESeqDataSet from count matrix and labels
dds <- DESeqDataSetFromMatrix(countData = countData, colData = sampleInformation, design = ~ TissueType)
# Run the default analysis for DESeq2 and generate a results table:
dds <- DESeq(dds)
# **
res <- results(dds)
# Sort by adjusted p-value and display:
resOrdered <- res[order(res$padj),]
resOrdered[1:100,]
```
** Note that the first time I ran this analysis I got an error about the design matrix having the same number of samples and coefficients to fit. This was because phenoData/sampleInformation originally had tissueType as WTa, WTb etc., which meant there were no reps. I have updated the ballgownPhenoData.csv file to reflect the presence of replicates.


## Table notes:
This produces a table of adjusted p.values. 
Gene names are present as MSTRG.xxxx and need to be converted to something useful.
The log2 fold change is for TissueType WT blast (underscore is not shown?) vs ConCap - I will need to further specify what I want to test using combinations with design. 
I have an adjusted p value of 1.2e-277 (!!!!)
In the previous analysis I did something where I adjusted for high and low expression (and how this relates to st.dev??). I need to re-read the notes from that analysis and find the code that was used, does this adjustment need to be done now. 


Additional arguments and things (e.g., shrinkage)
#################################################
## Notes from 20180213:
# Differential expression analysis
The standard differential expression analysis steps are wrapped into a single function, DESeq. The estimation steps performed by this function are described below, in the manual page for ?DESeq and in the Methods section of the DESeq2 publication (Love, Huber, and Anders 2014).
Results tables are generated using the function results, which extracts a results table with log2 fold changes, p values and adjusted p values. With no additional arguments to results, the log2 fold change and Wald test p value will be for the last variable in the design formula, and if this is a factor, the comparison will be the last level of this variable over the first level. However, the order of the variables of the design do not matter so long as the user specifies the comparison using the name or contrast arguments of results (described later and in ?results).
Details about the comparison are printed to the console, above the results table. The text, condition treated vs untreated, tells you that the estimates are of the logarithmic fold change log2(treated/untreated).
# Shrinkage
DESeq2 walkthrough mentions shrinkage estimate, which I've found an explanation for:
In previous versions of DESeq2, the DESeq function by default would produce moderated, or shrunken, log2 fold changes through the use of the betaPrior argument. In version 1.16 and higher, we have split the moderation of log2 fold changes into a separate function, lfcShrink, for reasons described in the changes section below.
Here we provide the dds object and the number of the coefficient we want to moderate. It is also possible to specify a contrast, instead of coef, which works the same as the contrast argument of the results function. If a results object is provided, the log2FoldChange column will be swapped out, otherwise lfcShrink returns a vector of shrunken log2 fold changes.
 Full methods are described in the DESeq2 paper (see DESeq2 citation), but in short, it looks at the largest fold changes that are not due to low counts and uses these to inform a prior distribution. So the large fold changes from genes with lots of statistical information are not shrunk, while the imprecise fold changes are shrunk. This allows you to compare all estimated LFC across experiments, for example, which is not really feasible without the use of a prior.
  - https://support.bioconductor.org/p/77461/

The code I used for shrinkage:
```{r}
# Make smaller version of dds which only looks at the first experiment
dds <- DESeqDataSetFromMatrix(countData = countData[,1:6], colData = sampleInformation[1:6,], design = ~ TissueType)
# Run the default analysis for DESeq2 and generate a results table:
dds <- DESeq(dds)
res <- results(dds)

# Carry out lfc shrinkage, based on the coef of choice (which I learn from resultsNames)
resultsNames(dds)
resLFC <- lfcShrink(dds, coef=2)

res[1:10,]
resLFC[1:10,]
# Shrinkage has been carried out, which can be observed in the log2FoldChange and lfcSE columns only. 

resLFCordered <- resLFC[order(resLFC$padj),]
resLFCordered[1:10,]

plotMA(res)
plotMA(resLFC)
# These code also came from the bioconductor support page linked directly above, but I am not really sure how to interpret. They do show a distinctive difference post lfc shrinkage
```

  
  

20180719
===================================================================================================================


Gain a better understanding of how to use the contrast argument in the DESeq results function. 
#############################################################################################
```{r}
# https://www.bioconductor.org/packages/devel/bioc/manuals/DESeq2/man/DESeq2.pdf page 41
res <- results(dds)
resConTest1 <- results(dds, contrast = c("TissueType","WT_blast","N1_nr"))
resConTest2 <- results(dds, contrast = c("TissueType","N1_nr","WT_blast"))
res[1:10,]
resConTest1[1:10,]
resConTest2[1:10,]
# These contrast tests demonstrate that log2FoldChange is reversed between 1 and 2. In the first instance, it is log2(WT_blast/N1_nr)

# This also shows how I can test for differences between specific conditions:
dds <- DESeqDataSetFromMatrix(countData = countData, colData = sampleInformation, design = ~ TissueType)
dds <- DESeq(dds)
sampleInformation
resConTest3 <- results(dds, contrast = c("TissueType","Tbud","PNT"))
resConTest3[1:10,]
resConTest4 <- results(dds, contrast = c("TissueType","ConCap","InjCap"))
resConTest4[1:10,]
# These share the same top genes, and log2FC/ stat do not appear to be appreciably different. 

resOrdered <- res[order(res$padj),]
resConTest3 <- resConTest3[order(resConTest3$padj),]
resConTest4 <- resConTest4[order(resConTest4$padj),]
resConTest3[1:10,]
resConTest4[1:10,]
# Once sorted by padj, the table results of TBud/PNT and ConCap/InjCap are quite different. 
```


Add gene names to LFC adjusted results. 
#############################################################################################
```{r}
stringtieMerged <- read.delim("~/hisatAnalysis/stringtieMerged.gtf", header=FALSE, comment.char="#")
stringtieMerged[1:3,]
dim(stringtieMerged)
spryCor <- grep("spry4",as.character(stringtieMerged[,9]))
as.vector(stringtieMerged[spryCor,9])

library(limma)
strsplit2(as.vector(stringtieMerged[spryCor,9]),";")[,c(1,3)]
# Since I'm working with gene counts, I will first try unique(MSTRGxxx) 

gd <- strsplit2(as.vector(stringtieMerged[,9]),";")[,c(1,3)]
gd[1:10,]
length(gd[,1])
length(unique(gd[,1]))
# 78,000 unique MSTRG
mstrgCodes <- strsplit2(unique(gd[,1])," ",fixed=T)[,2]
mstrgCodes[1:10]
gd[1:10,]
gd <- cbind(strsplit2(gd[,1]," ",fixed=T)[,2],gd[,2])
gd[1:100,]
mstrgToGene <- gd[grep("gene_name",as.vector(gd[,2])),]
dim(mstrgToGene)
length(unique(mstrgToGene[,1])) # 52485 mstrg tags
length(unique(mstrgToGene[,2])) # 49109 gene names
## Therefore some genes have multiple mstrg tags. 
# Which will be ok because the DESEq2 results are per mstrg. Multiple mstrg might map back to the same gene, but I won't have the issue of an mstrg tag mapping to the wrong gene (which could happen if this situation was reversed).


mstrgToGene[1:100,]
## Actually, when I look at the object, I can already see instances where one mstrg code encodes for multiple genes. e.g., mstrg31 matches ND1 and tRNA-Ile
setwd("~/Documents/tuxedoRNASeq/objectsTuxedoDESeq")
save(mstrgToGene,file='mstrgToGene.RData')
```







20180720
========================================================================================================================================================================

A single mstrg.xxxx id can match to multiple reference genes. 
Investigating this now, it is a known and recognised problem: https://github.com/gpertea/stringtie/issues/159
In this post, Pertea (first author of Tuxedo suite walkthrough "Transcript-level expression analysis of RNA-seq using Hisat, Stringtie and ballgown") states:

  "Firstly, please note that the MSTRG.# format .... they are gene (locus) IDs (the transcript IDs will have a different format, with another number added: MSTRG.#.#).

  The other issue you raised is StringTie gene/loci (MSTRG.#) matching multiple reference gene names ...

  This is actually the other reason why StringTie uses its own locus/gene IDs instead of reference gene IDs and names: because there are complex gene clusters like these where the alignments extend across multiple reference loci/genes, so the resulting StringTie locus(gene) encompasses multiple reference genes.. This could be caused by spurious alignments which are somewhat expected in situations like HLA gene clusters, or even intra-intron miRNA genes (like MIR6891) which are easily found to overlap incompletely spliced (or the retained introns of the) transcripts encompassing them (HLA transcripts in this example), and thus they'll be assigned the same StringTie gene/locus ID (MSTRG.18605 in this example).

  And in such "merged" reference loci cases there could be assembled transcripts overlapping reference transcripts belonging to different reference genes..(thus "bridging" those genes). What should StringTie show as the gene name in such cases? Both gene names? So you see, things can get hairy and that's why sticking to its own internally generated locus IDs like MSTRG.18605 is the unambiguous way for StringTie to report the results.
  "
And later states:
  "I agree that the annotation of StringTie's merged output is somewhat lacking at this point.. I am considering improving that in a future version by adding one ore more GTF tags that would actually show which reference gene_id (or gene_name, if the user prefers that) any particular StringTie output transcript might belong to (just by overlap, not by fully matching a reference transcript).
  Currently the user should use third party programs in order to actually annotate those cryptic MSTRG.ID loci and MSTRG.ID.ID transcripts in some cases. GffCompare can address some of it (with its "annotation mode") but I guess it still does not do it quite conveniently enough for easy inclusion in analysis pipelines.
  I'll leave this topic open (and of course take suggestions) until I get around implement (or find) a solution to properly address these needs of gene annotation of StringTie's output..
"
(Edited for clarity)


Moving forward, I will generate lists of DE MSTRG tags and then resolve tags to gene ID as best I can. 

I can now used the lfcShrink code from above to generate DE gene lists for each of the three experiments:

```{r}
rm(list=ls())
library(DESeq2)

# Read in count data:
countData <- as.matrix(read.csv("~/hisatAnalysis/stringtie_prepDE_output/stringtiePrepDE_geneCountMatrix.csv", row.names="gene_id"))
# Load sample information:
sampleInformation <- read.csv("~/hisatAnalysis/ballgownPhenodata.csv")
# Check that sample ID match between countData and sampleInformation
all(sampleInformation$ids %in% colnames(countData))

# Deseq2 object:
dds <- DESeqDataSetFromMatrix(countData = countData, colData = sampleInformation, design = ~ TissueType)
dds <- DESeq(dds)
resultsNames(dds)
# Generate results tables
WTN1res <- results(dds, contrast=c("TissueType", "Wtblast", "N1nr"))
TbudPNTres <- results(dds, contrast=c("TissueType", "Tbud", "PNT"))
ConCapInjCapres <- results(dds, contrast=c("TissueType", "ConCap", "InjCap"))
# Apply lfcShrink
WTN1res.lfc <- lfcShrink(dds, contrast=c("TissueType", "Wtblast", "N1nr"), res = WTN1res)
TbudPNTres.lfc <- lfcShrink(dds, contrast=c("TissueType", "Tbud", "PNT"), res = TbudPNTres)
ConCapInjCapres.lfc <- lfcShrink(dds, contrast=c("TissueType", "ConCap", "InjCap"), res = ConCapInjCapres)

ShrunkResults <- list(WTN1res.lfc, TbudPNTres.lfc, ConCapInjCapres.lfc)
class(ShrunkResults)
length(ShrunkResults)
names(ShrunkResults) <- c("WTN1res.lfc","TbudPNTres.lfc","ConCapInjCapres.lfc")

## NOTE: on p-values set to NA
#        If within a row, all samples have zero counts, the baseMean column will be zero, and the log2 fold change estimates, p-value and adjusted p-value will all be set to NA.
#        If a row contains a sample with an extreme count outlier then the p-value and adjusted p-value will be set to NA. These outlier counts are detected by Cookâ€™s distance.
#        If a row is filtered by automatic independent filtering, for having a low mean normalized count, then only the adjusted p-value will be set to NA

dim(WTN1res.lfc) # 77899 by 6
length(as.vector(na.omit(WTN1res.lfc$padj))) # there are 30515 genes with adjusted p values

# Remove rows with padj = NA
WTN1res.lfc <- WTN1res.lfc[!is.na(WTN1res.lfc$padj),]
table(WTN1res.lfc$padj < 0.05) # 2050 p values < 0.05, 28465 above

ShrunkResults <- lapply(1:length(ShrunkResults),function(x) ShrunkResults[[x]][!is.na(ShrunkResults[[x]]$padj),])
length(as.vector(na.omit(ShrunkResults[[1]]$padj)))
# Length of first item of ShrunkResultsNarm is the same as for the individual object - i.e., rows with NA values for padj have been removed. 

# Confirm objects look the same:
WTN1res.lfc
ShrunkResults[[1]] # yes they do


# Order the results table, retain padj < 0.05
WTN1_ord <- WTN1res.lfc[order(WTN1res.lfc$padj),]
WTN1_ord$padj[1100:2051] # shows that when sorted, the first 2050 p values are < 0.05, with the last row (2051) scoring 0.5001
WTN1_statSig <- WTN1_ord[as.vector(na.omit(WTN1_ord$padj < 0.05)),]
WTN1_statSig
dim(WTN1_statSig)
rm(WTN1_ord)

## For the three experiments:
shrunkPadjOrd <- lapply(1:length(ShrunkResults),function(x) ShrunkResults[[x]][order(ShrunkResults[[x]]$padj),])
# Confirm objects look same:
table(WTN1_ord %in% ShrunkResults[[1]][order(ShrunkResults[[1]]$padj),])
# Demonstrates objects are identical

statisticallySignificantShrunkPadj <- lapply(1:length(ShrunkResults),function(x) shrunkPadjOrd[[x]][as.vector(na.omit(shrunkPadjOrd[[x]]$padj < 0.05)),])
statisticallySignificantShrunkPadj[[1]]
# Confirm objects are the same:
table(WTN1_statSig %in% statisticallySignificantShrunkPadj[[1]]) # all 2050 rows are identical

# Order by log2FC, retain log2FC >1 or < -1
WTN1_ord <- WTN1_statSig[order(WTN1_statSig$log2FoldChange),]
WTN1_sigNeg <- WTN1_ord[as.vector(na.omit(WTN1_ord$log2FoldChange < -1)),]
WTN1_sigPos <- WTN1_ord[as.vector(na.omit(WTN1_ord$log2FoldChange > 1)),]
WTN1_sigNeg
WTN1_sigPos

# Repeat for all three experiments:
logOrd <- lapply(1:length(shrunkPadjOrd),function(x) statisticallySignificantShrunkPadj[[x]][order(statisticallySignificantShrunkPadj[[x]]$log2FoldChange),])
table(WTN1_ord %in% logOrd[[1]])
DEmstrgTagsNeg <- lapply(1:length(logOrd),function(x) logOrd[[x]][as.vector(na.omit(logOrd[[x]]$log2FoldChange < -1)),])
DEmstrgTagsPos <- lapply(1:length(logOrd),function(x) logOrd[[x]][as.vector(na.omit(logOrd[[x]]$log2FoldChange > 1)),])
# Confirm objects same:
table(WTN1_sigNeg %in% DEmstrgTagsNeg[[1]])
table(WTN1_sigPos %in% DEmstrgTagsPos[[1]])

# Tidy up:
names(DEmstrgTagsPos) <- c("WtVsN1nr","TbudVsPNT","ConCapVsInjCap")
names(DEmstrgTagsNeg) <- c("WtVsN1nr","TbudVsPNT","ConCapVsInjCap")
setwd("~/Documents/tuxedoRNASeq/objectsTuxedoDESeq")
save(DEmstrgTagsNeg,file='DEmstrgTagsNeg.RData')
save(DEmstrgTagsPos,file='DEmstrgTagsPos.RData')
save(ShrunkResults,file="ShrunkResults.RData")

rm(list=ls())
load("~/Documents/tuxedoRNASeq/DEmstrgTagsNeg.RData")
load("~/Documents/tuxedoRNASeq/DEmstrgTagsPos.RData")


# Summary of objects
ShrunkResults # lfcShrunk results table for each of the three experiments
DEmstrgTagsPos # /DEmstrgTagsNeg: for each of the three experiments, a matrix which includes only statistically (padj < 0.05) and biologically (log2FC >1 or < -1) significant genes. 
```




20180723 Coordinating mstrg tag and gene information
========================================================


```{r}
load("~/Documents/tuxedoRNASeq/mstrgToGene.RData")
match(rownames(DEmstrgTagsNeg[[1]]),as.vector(mstrgToGene[,1]))[1:50]
# See that many NAs appear (many DE mstrg tags are not found in the converter)

rownames(DEmstrgTagsNeg[[1]])[1:5]
# 1,2 and 5 (MSTRG.42597, .3952, .19112 respectively) are not showing up in the converter. 

## Open the stringtieMerged.gtf, search for those tags:
# MSTRG.42597: Is found in the gtf file, but has no gene name or ID. Has two rows: one with only a transcript ID (same as mstrg ID), and one with transcript ID plus "exon_number 1"
# MSTRG.3952: same as above
# MSTRG.19112: same as above, with an additional row for "exon_number 2"
```

Given that a number of mstrg tags do not have an associated gene name, I will need to make an improved mstrg-geneInfo converter which will retain those mstrg tags. 
```{r}
rm(mstrgToGene)

stringtieMerged <- read.delim("~/hisatAnalysis/stringtieMerged.gtf", header=FALSE, comment.char="#")

stringtieMerged[1:5,]
testString<- as.vector(stringtieMerged[,9])

# Experiment with different ways to sort and organise this information:
library(limma)
splitStrings <- strsplit2(testString,";",fixed=T)
splitStrings
uniqueMSTRG <- unique(splitStrings[,1])
uniqueMSTRG

# listFormat <- lapply(1:length(uniqueMSTRG),function(x) splitStrings[which(splitStrings[,1] %in% uniqueMSTRG[x]),])
# While it might be useful, the code above takes a long time to run. I'll make a simpler converter
names(listFormat) <- strsplit2(uniqueMSTRG," ",fixed=T)[,2]

as.vector(stringtieMerged[1:50,9])

gg <- as.vector(stringtieMerged[grep("gene_name",as.vector(stringtieMerged[,9])),9])
gg[1:10]
msWithGenes <- strsplit2(gg,";",fixed=T)[,1]
msWithGenes <- strsplit2(msWithGenes," ",fixed=T)[,2]
msWithGenes[1:10]
length(unique(msWithGenes)) # 52485
gene_names <- strsplit2(gg[match(unique(msWithGenes),msWithGenes)],";",fixed=T)[,3]
gene_names <- strsplit2(gene_names," ",fixed=T)[,3]
gene_names
length(gene_names) # 52485
length(unique(gene_names))

mstrgToGene <- cbind(unique(msWithGenes),gene_names)
mstrgToGene[1:50,]
mstrgToGene[order(mstrgToGene[,2])[1:50],]
save(mstrgToGene,file='mstrgToGene.RData')
```

Looking at mstrgToGene, I observe that some rows do NOT have an MSTRg number - instead they have geneXXXX. This occurs in 17618 cases (length(mstrgToGene[,1]) - length(grep("MSTRG",as.vector(mstrgToGene[,1]))) ). 
- These can be converted to Xenopus gene names using the Xenbase file geneID_converter


Extract DE mstrgs for each experiment, convert, save output. 

```{r}
DownregulatedMSTRGtags <- lapply(1:length(DEmstrgTagsNeg),function(x) as.vector(rownames(DEmstrgTagsNeg[[x]])))
UpregulatedMSTRGtags <- lapply(1:length(DEmstrgTagsPos),function(x) as.vector(rownames(DEmstrgTagsPos[[x]])))
names(DownregulatedMSTRGtags) <- c("Wt_N1nr", "Tbud_PNT","ConCap_InjCap")
names(UpregulatedMSTRGtags) <- c("Wt_N1nr", "Tbud_PNT","ConCap_InjCap")

unlist(lapply(1:3,function(x) length(UpregulatedMSTRGtags[[x]])))  # [1]  203 1076 6940
unlist(lapply(1:3,function(x) length(DownregulatedMSTRGtags[[x]])))  # [1]  598 4102 7584
## There are a lot of differentially expressed MSTRGtags.

# Convert to gene names
GenesDownReg <- lapply(1:length(DownregulatedMSTRGtags),function(x) mstrgToGene[match(DownregulatedMSTRGtags[[x]],as.vector(mstrgToGene[,1])),2])
GenesUpReg <- lapply(1:length(UpregulatedMSTRGtags),function(x) mstrgToGene[match(UpregulatedMSTRGtags[[x]],as.vector(mstrgToGene[,1])),2])

length(GenesDownReg[[1]]) # 598
length(na.omit(GenesDownReg[[1]])) #501
length(na.omit(unique(GenesDownReg[[1]]))) #497
length(GenesUpReg[[1]]) # 203
length(na.omit(unique(GenesUpReg[[1]]))) # 166

## Some of the rows in UpregulatedMSTRGtags[[x]] won't have mstrg tags but will instead have geneXXXX - which can be converted using the XEnbase file. 
# Convert to gene names, retrieve geneXXXX info
GenesDownReg <- lapply(1:length(DownregulatedMSTRGtags),function(x) mstrgToGene[match(DownregulatedMSTRGtags[[x]],as.vector(mstrgToGene[,1])),2])
GenesUpReg <- lapply(1:length(UpregulatedMSTRGtags),function(x) mstrgToGene[match(UpregulatedMSTRGtags[[x]],as.vector(mstrgToGene[,1])),2])
GenesDownReg <- lapply(1:length(GenesDownReg),function(x) c(GenesDownReg[[x]],DownregulatedMSTRGtags[[x]][grep("gene",DownregulatedMSTRGtags[[x]])]))
GenesUpReg <- lapply(1:length(GenesUpReg),function(x) c(GenesUpReg[[x]],UpregulatedMSTRGtags[[x]][grep("gene",UpregulatedMSTRGtags[[x]])]))

exptNames <- c("Wt_N1nr", "Tbud_PNT","ConCap_InjCap")
names(GenesDownReg) <- exptNames
names(GenesUpReg) <- exptNames

unlist(lapply(1:length(exptNames),function(x) length(GenesDownReg[[x]]))) # 604 4336 7873
unlist(lapply(1:length(exptNames),function(x) length(as.vector(na.omit(GenesDownReg[[x]]))))) # 507 3427 5876
unlist(lapply(1:length(exptNames),function(x) length(as.vector(na.omit(unique(GenesDownReg[[x]])))))) # 503 3383 5791
unlist(lapply(1:length(exptNames),function(x) length(GenesUpReg[[x]]))) # 204 1103 7112
unlist(lapply(1:length(exptNames),function(x) length(as.vector(na.omit(GenesUpReg[[x]]))))) # 167  857 5350
unlist(lapply(1:length(exptNames),function(x) length(as.vector(na.omit(unique(GenesUpReg[[x]])))))) # 167  853 5302

tuxedoDEgenes_mstrgConverted <- list(GenesUpReg,GenesDownReg)
names(tuxedoDEgenes_mstrgConverted) <- c("GenesUpReg","GenesDownReg")
getwd() #"/home/mcity599/Documents/tuxedoRNASeq"
save(tuxedoDEgenes_mstrgConverted,file='tuxedoDEgenes_mstrgConverted.RData')
```

Now open the PrepDE.py script, modify using the suggestion of https://www.biostars.org/p/269331/ and repeat this analysis to see whether alters the output. 
Looking at the output file, I see that this has successfully produced an output file with refGeneID in place of MSTRG tags - where they are available. Many rows do not have an associated Refgene id, and so these retain the mstrg tags. 
Checking mstrg tags against refGeneID from stringtieMerge, across both the prepDE and prepDE_refGeneID output files, I could see that the data aligns (i.e., mstrg matches to the genename I expect, counts are the same, and counts are similar within sample groups). 




EdgeR
===========================================================================================================
The next task is to repeat the analysis of differentially expressed genes using EdgeR. 

A note from the stringtie manual hints that I can use the code "DGEList" to bring these counts in for EdgeR analysis, the same as how I've used "DESeqDataSetFromMatrix" above for DESeq2. 


Install EdgeR
```{r}
source("https://bioconductor.org/biocLite.R")
biocLite()
biocLite("edgeR")
library(edgeR)
```




Referring to the EdgeR User's Guide: https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf
```{r}
countData <- as.matrix(read.csv("~/hisatAnalysis/stringtie_prepDE_output/stringtiePrepDE_geneCountMatrix.csv", row.names="gene_id"))
group <- factor(c(rep("A",3),rep("B",3),rep("C",3),rep("D",3),rep("E",3),rep("F",3)))
group
sampleInformation <- read.csv("~/hisatAnalysis/ballgownPhenodata.csv")
sampleInformation
sampleID <- sampleInformation$ids

y <- DGEList(counts = countData, group=group)
## There is no purpose in analysing genes that are not expressed in either experimental condition.  
# The user document proposes to consider a gene to be expressed at a reasonable level in a sample if it has at least two counts for each million mapped reads in that sample.  This cutoff is ad hoc, but serves to require at least 4â€“6 reads in this case.  Since this experiment has three replicates for each condition, a gene should be expressed in at least three samples if it responds to at least one condition.  Hence we keep genes with at least two counts per million (CPM) in at least three samples:
keep <- rowSums(cpm(y)>2) >= 3
table(keep)
# keep
# FALSE  TRUE 
# 50752 27147 
### Note that this is indicating of some 77,000 rows, only 27,000 are retained. This is a huge loss. 
# Testing dropping the threshold from rowSums as above - even dropping this to keep <- rowSums(cpm(y)>1) >= 3 retains only 32,000 rows. 
y <- y[keep, , keep.lib.sizes=FALSE]
y <- calcNormFactors(y)
```

A note on the effect of the keep filter:
- I originally did not run keep, and analysed all rows. This resulted in 328, 5717, and 17520 rows with an fdr padj < 0.05 (log2FC has not been used as a cutoff).
- After running filtering with keep, this results in 732, 6518, and 16820 rows with an fdr padj < 0.05



# Perform quasi-likelihood F-tests: (These are noted in the user guide to be the correct test to use as it uses stricter error rate control by accounting for the uncertainty in dispersion estimates)
## Refer to EdgeR user's guide Chapter 3 (Specific experimental designs)

```{r}
## How to use the exact test (not used here, as described above quasi-likelihood F-tests are better suited)

y$samples
levels(y$samples$group)

## Classic approach (pairwise exact tests)
et <- exactTest(y, pair=c("A","B"))
topTags(et)
et <- exactTest(y, pair=c("C","D"))
topTags(et)
```

In the above example, the 0+ in the formula is an instruction not to include an intercept column and instead to include a column for each group. 
Groups can then be compared using the contrast argument of the glmQLFTest or glmLRT function:

## Generalised linear model approach
```{r}
## GLM approach (requires a design matrix, allows more general comparisons to be made)
design <- model.matrix(~0+group, data=y$samples)
colnames(design) <- levels(y$samples$group)
design

y <- estimateGLMCommonDisp(y,design)
y <- estimateGLMTrendedDisp(y,design)
y <- estimateGLMTagwiseDisp(y,design)
fit <- glmQLFit(y, design)
qlf <- glmQLFTest(fit, contrast=c(-1,1,0,0,0,0))
# The contrast is to make the comparison -1*groupA + 1*groupB +0*groupC etc., for each group. The result of this is groupB - groupA
topTags(qlf)
## When I look at the output of topTags(qlf) and compare to topTags(et) (where et has been made with pair=c("A","B")), the results are similar: e.g., top tag is the same and has the same logFC although the P value and FDR are different. Of the top 10 tags, 7 are found in both et and qlf. 
### Referring to the user's guide, as well as information from various support pages, the exact test is to be used when two groups only are analysed, and a glm should be fit when there are more than two groups. 

# An alternative way to construct the contrast vector is with the makeContrasts function:
BvsA <- makeContrasts(B-A, levels=design)
qlf <- glmQLFTest(fit, contrast=BvsA)
topTags(qlf)
rm(BvsA)

# Use the makeContrasts function to set up potential tests between the three group-pairs:
my.contrasts <- makeContrasts(BvsA=B-A, DvsC=D-C, FvsE=F-E, levels=design)
my.contrasts
# Run tests:
qlf.BvsA <- glmQLFTest(fit, contrast=my.contrasts[,"BvsA"])
topTags(qlf.BvsA)
qlf.DvsC <- glmQLFTest(fit, contrast=my.contrasts[,"DvsC"])
topTags(qlf.DvsC)
qlf.FvsE <- glmQLFTest(fit, contrast=my.contrasts[,"FvsE"])
topTags(qlf.FvsE)
```


```{r}
plotMD(qlf.BvsA,main="WT vs NR") |abline(h=c(-1, 1), col="blue")
plotMD(qlf.DvsC) |abline(h=c(-1, 1), col="blue")
plotMD(qlf.FvsE) |abline(h=c(-1, 1), col="blue")
```

From the qlf. objects, how do I pull out the differentially expressed genes? Is every row significant? Or do I need to introduce cutoff values
```{r}
qlf.BvsA[1:10,]
qlf.BvsA$logFC # is null
?topTags
BvsAtags <- topTags(qlf.BvsA, n=Inf, adjust.method = "fdr", sort.by ="PValue", p.value = 0.05)
dim(BvsAtags)
rm(BvsAtags)

qlf_list <- list(qlf.BvsA,qlf.DvsC,qlf.FvsE)
names(qlf_list) <- c("qlf.BvsA","qlf.DvsC","qlf.FvsE")
qlfSigPTags <- lapply(1:length(qlf_list),function(x) topTags(qlf_list[[x]], n=Inf, adjust.method = "fdr", sort.by ="PValue", p.value = 0.05))
unlist(lapply(1:3,function(x) dim(qlfSigPTags[[x]]))) # 732 x 5,  6518 x 5, 16820 x 5
# i.e., 732, 6518, and 16820 significant tags
# Note: prior to filtering using keep (see above) the number of significant tags was: 328, 5717, 17520
dim(countData) # 77899 total rows
16820/77899 # Indicates between Con and InjCap, 21% of genes are DE (by p value only)
```

How to apply log2FC >1 / < -1 cutoff?
## Note that while the output of topTag(qlf...) says logFC - there is documentation which states this is in fact the log2FC. This has been discussed online in many posts (e.g., https://support.bioconductor.org/p/50273/, )
# Use qlfObject$table :
```{r}
qlfSigPTags[[1]]$table
qlfSigFoldTags <- lapply(1:length(qlfSigPTags),function(i) qlfSigPTags[[i]]$table)
names(qlfSigFoldTags) <- c("qlf.BvsA","qlf.DvsC","qlf.FvsE")
## Reminder: qlf.BvsA - a value with a positive logFC is upregulated in B relative to A
# Extract only logFC (log2FC) > 1 or < -1
qlfSigFoldTags[[1]][order(qlfSigFoldTags[[1]]$logFC),][qlfSigFoldTags[[1]][order(qlfSigFoldTags[[1]]$logFC),1] < -1,]
qlfSigFoldTags[[1]][order(qlfSigFoldTags[[1]]$logFC, decreasing=F),][qlfSigFoldTags[[1]][order(qlfSigFoldTags[[1]]$logFC, decreasing=F),1] >1,]

# For the list:
qlfSigFoldTags <- lapply(1:length(qlfSigPTags),function(i) qlfSigPTags[[i]]$table)
names(qlfSigFoldTags) <- c("qlf.BvsA","qlf.DvsC","qlf.FvsE")

qlfSigFoldTagsDown <- lapply(1:length(qlfSigPTags),function(t) qlfSigFoldTags[[t]][order(qlfSigFoldTags[[t]]$logFC),][qlfSigFoldTags[[t]][order(qlfSigFoldTags[[t]]$logFC),1] < -1,])
qlfSigFoldTagsUp <- lapply(1:length(qlfSigPTags),function(t) qlfSigFoldTags[[t]][order(qlfSigFoldTags[[t]]$logFC),][qlfSigFoldTags[[t]][order(qlfSigFoldTags[[t]]$logFC),1] >1,])
getwd()
# "/home/mcity599/Documents/tuxedoRNASeq"
save(qlfSigFoldTagsDown,file='qlfSigFoldTagsDown.RData')
save(qlfSigFoldTagsUp,file='qlfSigFoldTagsUp.RData')
# Manually move those saved files to EdgeR folder

unlist(lapply(1:3,function(x) length(rownames(qlfSigFoldTagsDown[[x]])))) # 105  803 5117 tags downregulated in the first group (BvsA) of each of the three expts
unlist(lapply(1:3,function(x) length(rownames(qlfSigFoldTagsUp[[x]])))) # 183 2770 5588 tags upregulated in the frist group in each of the three expts
```

Extract mstrg tags, convert
```{r}
tagsDown <- lapply(1:3,function(x) rownames(qlfSigFoldTagsDown[[x]]))
tagsUp <- lapply(1:3,function(x) rownames(qlfSigFoldTagsUp[[x]]))
# Convert:
load("~/Documents/tuxedoRNASeq/objectsTuxedoDESeq/mstrgToGene.RData")
EdgeR_downRegGenes <- lapply(1:3,function(b) mstrgToGene[na.omit(match(tagsDown[[b]],mstrgToGene[,1])),2])
EdgeR_upRegGenes <- lapply(1:3,function(b) mstrgToGene[na.omit(match(tagsUp[[b]],mstrgToGene[,1])),2])
EdgeR_upRegGenes[[1]] 
## Remember: the format for the contrast is BvsA, and a positive value is up in the first group (i.e., B) - therefore EdgeR_upRegGenes are genes which are upregulated in B compared to A (in the first expt this is upregulated in N1 relative to wt). 
```

Compare these DE genes to the DE genes from DESEq2
```{r}
load("~/Documents/tuxedoRNASeq/objectsTuxedoDESeq/tuxedoDEgenes_mstrgConverted.RData")
names(tuxedoDEgenes_mstrgConverted)
class(tuxedoDEgenes_mstrgConverted[[1]][1])
length(tuxedoDEgenes_mstrgConverted[[1]][[1]])
match(as.vector(na.omit(tuxedoDEgenes_mstrgConverted[[1]][[1]])),EdgeR_upRegGenes[[1]] )
table(as.vector(na.omit(tuxedoDEgenes_mstrgConverted[[2]][[1]])) %in% EdgeR_upRegGenes[[1]])
# 164 genes in common out of 604 (DESEq2, 80% overlap) or 166. From memory this is similar to what I observed earlier in the year, where one of these packages was less stringent than the other. 
## Also tells me that by setting my expt up with makeContrast as B-A I have flipped my data: EdgeR up genes are DESeq2 down genes

table(as.vector(na.omit(tuxedoDEgenes_mstrgConverted[[2]][[2]])) %in% EdgeR_upRegGenes[[2]])
#FALSE  TRUE 
# 1085  2342
length(as.vector(na.omit(tuxedoDEgenes_mstrgConverted[[2]][[2]]))) # 3427
length(EdgeR_upRegGenes[[2]]) # 2382
## 2342/2382 = 98% overlap for EdgeR, 2342/3427 = 68% overlap for DESeq2
```

```{r}
write.csv(EdgeR_upRegGenes[[1]],"upregulated in NR compared to WT.csv")
write.csv(EdgeR_upRegGenes[[2]],"upregulated in PNT compared to Tbud.csv")
write.csv(EdgeR_upRegGenes[[1]],"upregulated in InjCap compared to ConCap.csv")

write.csv(EdgeR_downRegGenes[[1]],"upregulated in WT compared to NR.csv")
write.csv(EdgeR_downRegGenes[[2]],"upregulated in Tbud compared to PNT.csv")
write.csv(EdgeR_downRegGenes[[3]],"upregulated in ConCap compared to InjCap.csv")
save(EdgeR_upRegGenes,file='EdgeR_upRegGenes.RData')
save(EdgeR_downRegGenes,file='EdgeR_downRegGenes.RData')
```


Compare the results from this analysis with the DE genes identified by EdgeR during the SALMON analysis:
```{r}
EdgeDE_Expt1OverExpressedWT <- read.csv("~/Documents/RnaR/rnaSeqRegen/EdgeR_diffExpressedGenes/EdgeDE_Expt1OverExpressedWT.csv")
dim(EdgeDE_Expt1OverExpressedWT) # 56 x 2
length(EdgeR_downRegGenes[[1]]) # 99
as.vector(EdgeDE_Expt1OverExpressedWT[,2])
length(unlist(lapply(1:length(as.vector(EdgeDE_Expt1OverExpressedWT[,2])),function(x) grep(as.vector(EdgeDE_Expt1OverExpressedWT[,2])[x],EdgeR_downRegGenes[[1]])))) / length(as.vector(EdgeR_downRegGenes[[1]])) # 30% of genes upregulated in WT compared to NR according to the Tuxedo-EdgeR analysis are the same as the genes found in the Salmon-EdgeR analysis. 

EdgeDE_Expt1OverExpressedNR <- read.csv("~/Documents/RnaR/rnaSeqRegen/EdgeR_diffExpressedGenes/EdgeDE_Expt1OverExpressedNR.csv")
length(unlist(lapply(1:length(as.vector(EdgeDE_Expt1OverExpressedNR[,2])),function(x) grep(as.vector(EdgeDE_Expt1OverExpressedNR[,2])[x],EdgeR_upRegGenes[[1]])))) / length(as.vector(EdgeR_upRegGenes[[1]])) # 29% overlap


EdgeDE_Expt2OverExpressedPNT <- read.csv("~/Documents/RnaR/rnaSeqRegen/EdgeR_diffExpressedGenes/EdgeDE_Expt2OverExpressedPNT.csv")
length(unlist(lapply(1:length(as.vector(EdgeDE_Expt2OverExpressedPNT[,2])),function(x) grep(as.vector(EdgeDE_Expt2OverExpressedPNT[,2])[x],EdgeR_upRegGenes[[2]])))) / length(as.vector(EdgeR_upRegGenes[[2]])) # 37.6%


EdgeDE_Expt2OverExpressedTbud <- read.csv("~/Documents/RnaR/rnaSeqRegen/EdgeR_diffExpressedGenes/EdgeDE_Expt2OverExpressedTbud.csv")
length(unlist(lapply(1:length(as.vector(EdgeDE_Expt2OverExpressedTbud[,2])),function(x) grep(as.vector(EdgeDE_Expt2OverExpressedTbud[,2])[x],EdgeR_downRegGenes[[2]])))) / length(as.vector(EdgeR_downRegGenes[[2]])) # 25%

EdgeDE_Expt3OverExpressedConCap <- read.csv("~/Documents/RnaR/rnaSeqRegen/EdgeR_diffExpressedGenes/EdgeDE_Expt3OverExpressedConCap.csv")
length(unlist(lapply(1:length(as.vector(EdgeDE_Expt3OverExpressedConCap[,2])),function(x) grep(as.vector(EdgeDE_Expt3OverExpressedConCap[,2])[x],EdgeR_downRegGenes[[3]])))) / length(as.vector(EdgeR_downRegGenes[[3]])) # 34%


## Compared to the last analysis using EdgeR the results are comparable. Not excellent, but finding that approximately 1/4 to 1/3 overlap confirms that the experiments are what I think they are (at least have internal consistency for what is up in which sample). 
```




Going back to take a better look at Dispersion:

Dispersion:
What do these do?
y <- estimateGLMCommonDisp(y,design)
y <- estimateGLMTrendedDisp(y,design)
y <- estimateGLMTagwiseDisp(y,design)
Make plots for dispersion:

Referring to the EdgeR User's Guide: https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf
```{r}
rm(list=ls())

library(edgeR)

countData <- as.matrix(read.csv("~/hisatAnalysis/stringtie_prepDE_output/stringtiePrepDE_geneCountMatrix.csv", row.names="gene_id"))
group <- factor(c(rep("A",3),rep("B",3),rep("C",3),rep("D",3),rep("E",3),rep("F",3)))
sampleInformation <- read.csv("~/hisatAnalysis/ballgownPhenodata.csv")

# Filter genes not expressed:
y <- DGEList(counts = countData, group=group)
keep <- rowSums(cpm(y)>2) >= 3
table(keep)
y <- y[keep, , keep.lib.sizes=FALSE]
y <- calcNormFactors(y)
```






sampleID <- sampleInformation$ids



# Perform quasi-likelihood F-tests: (These are noted in the user guide to be the correct test to use as it uses stricter error rate control by accounting for the uncertainty in dispersion estimates)
## Refer to EdgeR user's guide Chapter 3 (Specific experimental designs)

```{r}
## How to use the exact test (not used here, as described above quasi-likelihood F-tests are better suited)

y$samples
levels(y$samples$group)

## Classic approach (pairwise exact tests)
et <- exactTest(y, pair=c("A","B"))
topTags(et)
et <- exactTest(y, pair=c("C","D"))
topTags(et)
```

In the above example, the 0+ in the formula is an instruction not to include an intercept column and instead to include a column for each group. 
Groups can then be compared using the contrast argument of the glmQLFTest or glmLRT function:

## Generalised linear model approach
```{r}
## GLM approach (requires a design matrix, allows more general comparisons to be made)
design <- model.matrix(~0+group, data=y$samples)
colnames(design) <- levels(y$samples$group)
design

y <- estimateGLMCommonDisp(y,design)
y <- estimateGLMTrendedDisp(y,design)
y <- estimateGLMTagwiseDisp(y,design)
fit <- glmQLFit(y, design)
qlf <- glmQLFTest(fit, contrast=c(-1,1,0,0,0,0))
# The contrast is to make the comparison -1*groupA + 1*groupB +0*groupC etc., for each group. The result of this is groupB - groupA
topTags(qlf)
## When I look at the output of topTags(qlf) and compare to topTags(et) (where et has been made with pair=c("A","B")), the results are similar: e.g., top tag is the same and has the same logFC although the P value and FDR are different. Of the top 10 tags, 7 are found in both et and qlf. 
### Referring to the user's guide, as well as information from various support pages, the exact test is to be used when two groups only are analysed, and a glm should be fit when there are more than two groups. 

# An alternative way to construct the contrast vector is with the makeContrasts function:
BvsA <- makeContrasts(B-A, levels=design)
qlf <- glmQLFTest(fit, contrast=BvsA)
topTags(qlf)
rm(BvsA)

# Use the makeContrasts function to set up potential tests between the three group-pairs:
my.contrasts <- makeContrasts(BvsA=B-A, DvsC=D-C, FvsE=F-E, levels=design)
my.contrasts
# Run tests:
qlf.BvsA <- glmQLFTest(fit, contrast=my.contrasts[,"BvsA"])
topTags(qlf.BvsA)
qlf.DvsC <- glmQLFTest(fit, contrast=my.contrasts[,"DvsC"])
topTags(qlf.DvsC)
qlf.FvsE <- glmQLFTest(fit, contrast=my.contrasts[,"FvsE"])
topTags(qlf.FvsE)
```


```{r}
plotMD(qlf.BvsA,main="WT vs NR") |abline(h=c(-1, 1), col="blue")
plotMD(qlf.DvsC) |abline(h=c(-1, 1), col="blue")
plotMD(qlf.FvsE) |abline(h=c(-1, 1), col="blue")
```

From the qlf. objects, how do I pull out the differentially expressed genes? Is every row significant? Or do I need to introduce cutoff values
```{r}
qlf.BvsA[1:10,]
qlf.BvsA$logFC # is null
?topTags
BvsAtags <- topTags(qlf.BvsA, n=Inf, adjust.method = "fdr", sort.by ="PValue", p.value = 0.05)
dim(BvsAtags)
rm(BvsAtags)

qlf_list <- list(qlf.BvsA,qlf.DvsC,qlf.FvsE)
names(qlf_list) <- c("qlf.BvsA","qlf.DvsC","qlf.FvsE")
qlfSigPTags <- lapply(1:length(qlf_list),function(x) topTags(qlf_list[[x]], n=Inf, adjust.method = "fdr", sort.by ="PValue", p.value = 0.05))
unlist(lapply(1:3,function(x) dim(qlfSigPTags[[x]]))) # 732 x 5,  6518 x 5, 16820 x 5
# i.e., 732, 6518, and 16820 significant tags
# Note: prior to filtering using keep (see above) the number of significant tags was: 328, 5717, 17520
dim(countData) # 77899 total rows
16820/77899 # Indicates between Con and InjCap, 21% of genes are DE (by p value only)
```

How to apply log2FC >1 / < -1 cutoff?
## Note that while the output of topTag(qlf...) says logFC - there is documentation which states this is in fact the log2FC. This has been discussed online in many posts (e.g., https://support.bioconductor.org/p/50273/, )
# Use qlfObject$table :
```{r}
qlfSigPTags[[1]]$table
qlfSigFoldTags <- lapply(1:length(qlfSigPTags),function(i) qlfSigPTags[[i]]$table)
names(qlfSigFoldTags) <- c("qlf.BvsA","qlf.DvsC","qlf.FvsE")
## Reminder: qlf.BvsA - a value with a positive logFC is upregulated in B relative to A
# Extract only logFC (log2FC) > 1 or < -1
qlfSigFoldTags[[1]][order(qlfSigFoldTags[[1]]$logFC),][qlfSigFoldTags[[1]][order(qlfSigFoldTags[[1]]$logFC),1] < -1,]
qlfSigFoldTags[[1]][order(qlfSigFoldTags[[1]]$logFC, decreasing=F),][qlfSigFoldTags[[1]][order(qlfSigFoldTags[[1]]$logFC, decreasing=F),1] >1,]

# For the list:
qlfSigFoldTags <- lapply(1:length(qlfSigPTags),function(i) qlfSigPTags[[i]]$table)
names(qlfSigFoldTags) <- c("qlf.BvsA","qlf.DvsC","qlf.FvsE")

qlfSigFoldTagsDown <- lapply(1:length(qlfSigPTags),function(t) qlfSigFoldTags[[t]][order(qlfSigFoldTags[[t]]$logFC),][qlfSigFoldTags[[t]][order(qlfSigFoldTags[[t]]$logFC),1] < -1,])
qlfSigFoldTagsUp <- lapply(1:length(qlfSigPTags),function(t) qlfSigFoldTags[[t]][order(qlfSigFoldTags[[t]]$logFC),][qlfSigFoldTags[[t]][order(qlfSigFoldTags[[t]]$logFC),1] >1,])
getwd()
# "/home/mcity599/Documents/tuxedoRNASeq"
save(qlfSigFoldTagsDown,file='qlfSigFoldTagsDown.RData')
save(qlfSigFoldTagsUp,file='qlfSigFoldTagsUp.RData')
# Manually move those saved files to EdgeR folder

unlist(lapply(1:3,function(x) length(rownames(qlfSigFoldTagsDown[[x]])))) # 105  803 5117 tags downregulated in the first group (BvsA) of each of the three expts
unlist(lapply(1:3,function(x) length(rownames(qlfSigFoldTagsUp[[x]])))) # 183 2770 5588 tags upregulated in the frist group in each of the three expts
```

Extract mstrg tags, convert
```{r}
tagsDown <- lapply(1:3,function(x) rownames(qlfSigFoldTagsDown[[x]]))
tagsUp <- lapply(1:3,function(x) rownames(qlfSigFoldTagsUp[[x]]))
# Convert:
load("~/Documents/tuxedoRNASeq/objectsTuxedoDESeq/mstrgToGene.RData")
EdgeR_downRegGenes <- lapply(1:3,function(b) mstrgToGene[na.omit(match(tagsDown[[b]],mstrgToGene[,1])),2])
EdgeR_upRegGenes <- lapply(1:3,function(b) mstrgToGene[na.omit(match(tagsUp[[b]],mstrgToGene[,1])),2])
EdgeR_upRegGenes[[1]] 
## Remember: the format for the contrast is BvsA, and a positive value is up in the first group (i.e., B) - therefore EdgeR_upRegGenes are genes which are upregulated in B compared to A (in the first expt this is upregulated in N1 relative to wt). 
```

Compare these DE genes to the DE genes from DESEq2
```{r}
load("~/Documents/tuxedoRNASeq/objectsTuxedoDESeq/tuxedoDEgenes_mstrgConverted.RData")
names(tuxedoDEgenes_mstrgConverted)
class(tuxedoDEgenes_mstrgConverted[[1]][1])
length(tuxedoDEgenes_mstrgConverted[[1]][[1]])
match(as.vector(na.omit(tuxedoDEgenes_mstrgConverted[[1]][[1]])),EdgeR_upRegGenes[[1]] )
table(as.vector(na.omit(tuxedoDEgenes_mstrgConverted[[2]][[1]])) %in% EdgeR_upRegGenes[[1]])
# 164 genes in common out of 604 (DESEq2, 80% overlap) or 166. From memory this is similar to what I observed earlier in the year, where one of these packages was less stringent than the other. 
## Also tells me that by setting my expt up with makeContrast as B-A I have flipped my data: EdgeR up genes are DESeq2 down genes

table(as.vector(na.omit(tuxedoDEgenes_mstrgConverted[[2]][[2]])) %in% EdgeR_upRegGenes[[2]])
#FALSE  TRUE 
# 1085  2342
length(as.vector(na.omit(tuxedoDEgenes_mstrgConverted[[2]][[2]]))) # 3427
length(EdgeR_upRegGenes[[2]]) # 2382
## 2342/2382 = 98% overlap for EdgeR, 2342/3427 = 68% overlap for DESeq2
```

```{r}
write.csv(EdgeR_upRegGenes[[1]],"upregulated in NR compared to WT.csv")
write.csv(EdgeR_upRegGenes[[2]],"upregulated in PNT compared to Tbud.csv")
write.csv(EdgeR_upRegGenes[[1]],"upregulated in InjCap compared to ConCap.csv")

write.csv(EdgeR_downRegGenes[[1]],"upregulated in WT compared to NR.csv")
write.csv(EdgeR_downRegGenes[[2]],"upregulated in Tbud compared to PNT.csv")
write.csv(EdgeR_downRegGenes[[3]],"upregulated in ConCap compared to InjCap.csv")
save(EdgeR_upRegGenes,file='EdgeR_upRegGenes.RData')
save(EdgeR_downRegGenes,file='EdgeR_downRegGenes.RData')
```
==============================================


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
